#!/usr/bin/env python

# ######Comments##
# This implmentation is for getting an observation error function using ar tags for HBLQR implmentation on robot.
# The observation error function is generated by comparing the observations obtained from the ar tags and the
# observations obtained from the transformations. Assumptions: the grip of the eef on the leg remains rigid throughout\
# the experiment and hence the tf between the two is fixed. The tf observations are obtained by intially deciding the tf between
# the leg and the eef by gathering the ar_tag data and as the tf remiains fixed, the same 
# tf is then broadcasted to the tf tree using a tf_broadcaster. End result: an array of error at 14 different locations
# along the demonstrated trajectory.


import sys
import os
import rospy
import copy
import moveit_commander
import moveit_msgs.msg
import moveit_msgs.srv
import geometry_msgs.msg
import wpi_jaco_msgs.msg
import wpi_jaco_msgs.srv
import time
from math import pi, floor, ceil, fabs, sin, cos, radians,degrees
from vector_msgs.msg import JacoCartesianVelocityCmd, LinearActuatorCmd, GripperCmd, GripperStat
import requests
import tf2_ros
import tf2_geometry_msgs
import tf
import tf2_msgs.msg
from ar_track_alvar_msgs.msg import *
from interactive_markers.interactive_marker_server import *
from visualization_msgs.msg import *
from std_msgs.msg import *
import numpy as np

import gazebo_msgs.srv
from gemini_experimental_utils.srv import object_frame_data
from shape_msgs.msg import SolidPrimitive

# For plotting
import matplotlib.pyplot as plt

from utils import *

############## Planning Algortihm
class WayPoints:

	def __init__(self, z_init): #, x_init):
		self.nState = 6
		# self.goal = goal

		self.arm_name = 'left'

		self.waypts = None
		self.jointTraj_waypoint() # Setting up the waypoints of Joint Trajectory
		self.n_waypoints = len(self.waypts)

		## Transformations Handling
		self.t = geometry_msgs.msg.PoseStamped()
		self.t2 = geometry_msgs.msg.PoseStamped()
		self.t3 = geometry_msgs.msg.Pose()

		self.start = z_init

		# Initialization of tf between left ee link and the object frame 
		quat = tf.transformations.quaternion_from_euler(self.start[3],self.start[4],self.start[5])
		self.t.header.stamp = rospy.Time.now()
		self.t.pose.position.x = self.start[0]
		self.t.pose.position.y = self.start[1]
		self.t.pose.position.z = self.start[2]
		self.t.pose.orientation.x = quat[0]
		self.t.pose.orientation.y = quat[1]
		self.t.pose.orientation.z = quat[2]
		self.t.pose.orientation.w = quat[3]
		# self.t.pose.orientation.x = self.start[3]
		# self.t.pose.orientation.y = self.start[4]
		# self.t.pose.orientation.z = self.start[5]
		# self.t.pose.orientation.w = self.start[6]

		self.serv = rospy.Service('object_frame_tf', object_frame_data, self.handle_waypointServer)

		## ROS nodes for frame transformation
		self.tfBuffer = tf2_ros.Buffer()
		listener = tf2_ros.TransformListener(self.tfBuffer)

	def init_pose(self):
		return [-1.01, 1.622, 1.75, 0.045, 1.979, -0.573]
		
	
	def handle_waypointServer(self,req):
		return self.t.header, self.t.pose

	def jointTraj_waypoint(self):
		wp = [[-1.165, 1.892, 1.962, 0.044, 1.979, -0.566]]
		wp = wp + [[-1.175, 1.901, 1.962, 0.044, 1.979, -0.566]]
		wp = wp + [[-1.275, 2.152, 2.255, 0.044, 1.978, -0.566]]
		wp = wp + [[-1.65, 2.569, 2.783, 0.35, 2.038, -0.564]]
		wp = wp + [[-1.683, 2.254, 2.066, -0.384, 1.676, 0.008]]
		wp = wp + [[-1.683, 2.221, 2.066, -0.384, 1.677, 1.462]]
		wp = wp + [[-1.683, 2.221, 2.066, -0.384, 1.677, 3.462]]
		wp = wp + [[-1.683, 2.221, 2.066, -0.384, 1.677, 4.462]]
		wp = wp + [[-1.683, 2.221, 2.066, -0.384, 1.677, 5.462]]

		self.waypts = wp*1

		# self.waypts[0,:] = np.array([-1.165, 1.892, 1.962, 0.044, 1.979, -0.566])
		# self.waypts[1,:] = np.array([-1.175, 1.901, 1.962, 0.044, 1.979, -0.566])
		# self.waypts[2,:] = np.array([-1.275, 2.152, 2.255, 0.044, 1.978, -0.566])
		# self.waypts[3,:] = np.array([-1.65, 2.569, 2.783, 0.35, 2.038, -0.564])
		# self.waypts[4,:] = np.array([-1.724, 2.591, 2.748, 0.262, 2.08, -0.561])
		# self.waypts[5,:] = np.array([-1.321, 2.529, 2.697, -0.385, 2.08, -0.5617])
		# self.waypts[6,:] = np.array([-1.08, 2.571, 2.708, -0.638, 2.08, -0.561])
		# self.waypts[7,:] = np.array([-1.36, 2.605, 2.71, -0.273, 2.087, -0.561])
		# self.waypts[8,:] = np.array([-1.523, 2.451, 2.429, -0.271, 2.091, -0.561])
		# self.waypts[9,:] = np.array([-1.291, 2.143, 1.947, -0.538, 1.873, -0.561])
		# self.waypts[10,:] = np.array([-1.692, 2.256, 2.066, -0.384, 1.675, -0.561])
		# self.waypts[11,:] = np.array([-1.683, 2.254, 2.066, -0.384, 1.676, 0.008])
		# self.waypts[12,:] = np.array([-1.685, 2.248, 2.066, -0.384, 1.677, 0.744])
		# self.waypts[13,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 1.462])
		# self.waypts[14,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 3.462])
		# self.waypts[15,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 5.462])
		# self.waypts[16,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 10.462])
		# self.waypts[17,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 15.462])

		# self.waypts[0,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 1.462])
		# self.waypts[1,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 3.462])
		# self.waypts[2,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 5.462])
		# self.waypts[3,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 10.462])
		# self.waypts[4,:] = np.array([-1.683, 2.221, 2.066, -0.384, 1.677, 15.462])
		return

	def array2Pose(self, arr):
		pose = geometry_msgs.msg.Pose()

		pose.position.x = arr[0]
		pose.position.y = arr[1]
		pose.position.z = arr[2]

		quat = tf.transformations.quaternion_from_euler(arr[3], arr[4], arr[5])
		pose.orientation.x = quat[0]
		pose.orientation.y = quat[1]
		pose.orientation.z = quat[2]
		pose.orientation.w = quat[3]

		return pose

######################## FOr Observations -- Feedback


class TagTracking():

	def __init__(self):

		# Adjusitng the Kinect angle
		self.kinect_angle_pub = rospy.Publisher('/tilt_controller/command', Float64, queue_size=10)
		self.kinect_angle = Float64()
		self.kinect_angle.data = 0.7
		self.kinect_angle_pub.publish(self.kinect_angle)
		rospy.sleep(1)
		
		# Transform Listener
		tfBuffer = tf2_ros.Buffer()
		listener = tf2_ros.TransformListener(tfBuffer)
		# self.trans = tfBuffer.lookup_transform("linear_actuator_link","kinect_link",rospy.Time(0), rospy.Duration(2.0))
		
		self.publisher = rospy.Publisher('visualization_marker_array', MarkerArray, queue_size=10)
		self.markerArray = MarkerArray()


		self.legPose = np.zeros(6)
		self.tablePose = np.zeros(6)
		self.gotData = None
		self.correctAngle = False
		self.angMean = np.zeros(3)
		self.nMean = 0

		rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.arPoseMarkerCallback)
		rospy.sleep(1)


	def arPoseMarkerCallback(self, msg):
		if(len(msg.markers)>0):
			self.gotData = True
			mark = msg.markers[0]

			quat = (mark.pose.pose.orientation.x, mark.pose.pose.orientation.y, mark.pose.pose.orientation.z, mark.pose.pose.orientation.w)
			euler = tf.transformations.euler_from_quaternion(quat)
			
			# if self.correctAngle == True:
			# 	euler = self.angle_correction(euler, self.legPose[3:])
			euler = angle_correction(euler, self.legPose[3:])

			self.angMean = (self.angMean*self.nMean + euler)/(self.nMean+1)
			self.nMean += 1

			self.legPose[0] = mark.pose.pose.position.x
			self.legPose[1] = mark.pose.pose.position.y
			self.legPose[2] = mark.pose.pose.position.z
			self.legPose[3] = euler[0]
			self.legPose[4] = euler[1]
			self.legPose[5] = euler[2]
			# self.legPose[3] = mark.pose.pose.orientation.x
			# self.legPose[4] = mark.pose.pose.orientation.y
			# self.legPose[5] = mark.pose.pose.orientation.z
			# self.legPose[6] = mark.pose.pose.orientation.w


			if(len(msg.markers)>1):
				## Table Pose
				table = msg.markers[1]
				quat1 = (table.pose.pose.orientation.x, table.pose.pose.orientation.y, table.pose.pose.orientation.z, table.pose.pose.orientation.w)
				euler1 = tf.transformations.euler_from_quaternion(quat1)
				
				self.tablePose[0] = table.pose.pose.position.x
				self.tablePose[1] = table.pose.pose.position.y
				self.tablePose[2] = table.pose.pose.position.z
				self.tablePose[3] = euler1[0]
				self.tablePose[4] = euler1[1]
				self.tablePose[5] = euler1[2]

		else:
			# print "No observation recieved"
			self.gotData = False

	def getObservation(self):
		### For the robot
		self.correctAngle = True
		z = self.legPose #- self.tablePose  # Feedback defined by the relative distance between the leg and the table
		return z


################## Trajectory Execution
class ArmMoveIt:

	def __init__(self, planning_frame='linear_actuator_link', default_planner="RRTConnectkConfigDefault"):

		# Make sure the moveit service is up and running
		rospy.logwarn("Waiting for MoveIt! to load")
		try:
			rospy.wait_for_service('compute_ik')
		except rospy.ROSExecption, e:
			rospy.logerr("No moveit service detected. Exiting")
			exit()
		else:
			rospy.loginfo("MoveIt detected: arm planner loading")

		self.arm_name = 'left'
		self.robot = moveit_commander.RobotCommander()
		self.scene = moveit_commander.PlanningSceneInterface()
		self.group = [moveit_commander.MoveGroupCommander(self.arm_name + '_arm')]
		self.planner = default_planner
		self.group[0].set_pose_reference_frame(planning_frame)
		# self.continuous_joints = ['left_shoulder_pan_joint', 'left_shoulder_lift_joint', 'left_elbow_joint', 'left_wrist_1_joint', 'left_wrist_2_joint', 'left_wrist_3_joint']
		self.continuous_joints = [self.arm_name + '_shoulder_pan_joint', self.arm_name + '_shoulder_lift_joint', self.arm_name + '_elbow_joint', \
								 self.arm_name + '_wrist_1_joint', self.arm_name + '_wrist_2_joint', self.arm_name + '_wrist_3_joint']
		self.continuous_joints_list = [0,3,4,5,6,9,10,11] # joints that are continous

		self.tfBuffer = tf2_ros.Buffer()
		self.listener = tf2_ros.TransformListener(self.tfBuffer)
		self.markerArray = MarkerArray()
		self.co_publisher = rospy.Publisher('visualization_marker_array', MarkerArray, queue_size=10)

		# NOTE: order that moveit currently is configured
	 

	def get_IK(self, newPose, root = None):
		## from a defined newPose (geometry_msgs.msg.Pose()), return its correspondent joint angle(list)
		rospy.wait_for_service('compute_ik')
		compute_ik = rospy.ServiceProxy('compute_ik', moveit_msgs.srv.GetPositionIK)

		wkPose = geometry_msgs.msg.PoseStamped()
		if root is None:
			# wkPose.header.frame_id = self.group[0].get_planning_frame() # name:odom
			wkPose.header.frame_id = 'linear_actuator_link'
		else:
			wkPose.header.frame_id = root

		wkPose.header.stamp=rospy.Time.now()
		wkPose.pose=newPose

		msgs_request = moveit_msgs.msg.PositionIKRequest()
		msgs_request.group_name = self.arm_name + '_arm';
		# msgs_request.group_name = self.group[0].get_name() # name: arm
		# msgs_request.robot_state = robot.get_current_state()
		msgs_request.pose_stamped = wkPose
		msgs_request.timeout.secs = 2
		msgs_request.avoid_collisions = False ######################### Shouldn't this be true??

		try:
			jointAngle=compute_ik(msgs_request)
			ans=list(jointAngle.solution.joint_state.position[1:7])
			if jointAngle.error_code.val == -31:
				print 'No IK solution'
				return None
			return ans

		except rospy.ServiceException, e:
			print "Service call failed: %s"%e


	def _simplify_angle(self, angle):
		# Very simple function that makes sure the angles are between -pi and pi
		# if angle > pi:
		# 	while angle > pi:
		# 		angle -= 2*pi
		# elif angle < -pi:
		# 	while angle < -pi:
		# 		angle += 2*pi

		return angle


	def _simplify_joints(self, joint_dict):
		if isinstance(joint_dict, dict):
		  simplified_joints = dict()
		  for joint in joint_dict:
			# Pull out the name of the joint
			joint_name = '_'.join(joint.split('_')[1::])
			if joint_name in self.continuous_joints:
			  simplified_joints[joint] = self._simplify_angle(joint_dict[joint])
			else:
			  simplified_joints[joint] = joint_dict[joint]

		elif isinstance(joint_dict, list):
		  simplified_joints = []
		  for i in xrange(len(joint_dict)):
			
			a = joint_dict[i]

			if i in self.continuous_joints_list:
			  simplified_joints.append(self._simplify_angle(a))
			else:
			  simplified_joints.append(a)

		return simplified_joints


	def plan_jointTargetInput(self,target_joint,n):
		## input: target joint angles (list) of the robot
		## output: plan from current joint angles to the target one
		try:
		  self.group[n].set_joint_value_target(self._simplify_joints(target_joint))
		  self.group[n].set_planner_id(self.planner)
		  planAns=self.group[n].plan()
		  return planAns
		except:
		  print 'No plan found, see the moveit terminal for the error'
		  print("Unexpected error:", sys.exc_info()[1])
		  return None



### Coliision Object specification
# 	def attach_object(self):
# 		# Using Planning Scene interface
# 		dimensions = [0.5, 0.2, 0.2]

# 		trans = self.tfBuffer.lookup_transform('linear_actuator_link', self.arm_name + '_ee_link', rospy.Time(), rospy.Duration(3.0))

# 		marker_pos = geometry_msgs.msg.Pose()
# 		marker_pos.position.x = trans.transform.translation.x
# 		marker_pos.position.y = trans.transform.translation.y
# 		marker_pos.position.z = trans.transform.translation.z
# 		marker_pos.orientation.x = trans.transform.rotation.x
# 		marker_pos.orientation.y = trans.transform.rotation.y
# 		marker_pos.orientation.z = trans.transform.rotation.z
# 		marker_pos.orientation.w = trans.transform.rotation.w


# 		# self.scene.add_box('leg', size=dimensions)
# 		self.scene.attach_box(self.arm_name + '_ee_link', 'leg', size = dimensions)
# 		self.group[0].set_planning_time(10.0)
# 		rospy.sleep(4)

# 	def vis_collision_object(self):
# 		trans = self.tfBuffer.lookup_transform('linear_actuator_link', self.arm_name + '_ee_link', rospy.Time(), rospy.Duration(3.0))

# 		marker_pos = geometry_msgs.msg.Pose()
# 		print "Parent Frame =", trans.header.frame_id
# 		marker_pos.position.x = trans.transform.translation.x
# 		marker_pos.position.y = trans.transform.translation.y
# 		marker_pos.position.z = trans.transform.translation.z
# 		marker_pos.orientation.x = trans.transform.rotation.x
# 		marker_pos.orientation.y = trans.transform.rotation.y
# 		marker_pos.orientation.z = trans.transform.rotation.z
# 		marker_pos.orientation.w = trans.transform.rotation.w

# 		marker = Marker()
# 		scale = [0.5, 0.2, 0.2]
# 		color = [1., 0., 0.]
# 		marker.type = marker.CUBE
# 		marker.action = marker.ADD
# 		marker.scale.x = scale[0]
# 		marker.scale.y = scale[1]
# 		marker.scale.z = scale[2]
# 		marker.color.a = 1.0
# 		marker.color.r = color[0]
# 		marker.color.g= color[1]
# 		marker.color.b = color[2]
# 		marker.pose = marker_pos
# 		# print "Marker_pose = ", marker_pos
# 		marker.header.frame_id = 'linear_actuator_link'
# 		marker.header.stamp = rospy.Time.now()
# 		# print self.marker
# 		# markerArray = MarkerArray()
# 		self.markerArray.markers.append(marker)
# 		self.co_publisher.publish(self.markerArray)



######################## Main function
def main():
	tags = TagTracking()
	arm = ArmMoveIt()

# 	# Attaching the leg as collision object
# 	print "Visualizing the Collision Object"
# 	while(not(rospy.is_shutdown())):
# 		arm.attach_object()
# 		arm.vis_collision_object()
# 		rospy.sleep(0.1)
		
# 	# start_pt = np.array([0.67067, 0.28389, 0.5, 0.231, 0.165, -1.019])
# 	# goal_pt = np.array([0.95281016, 0.13576, -0.052,  0.072, 0.323, -1.145])
	
	
# 	for i in range(10):
# 		z_obs = tags.getObservation()
		
	rospy.sleep(5)
	z_obs = tags.getObservation()

	tarPose = geometry_msgs.msg.Pose()

	planner = WayPoints(z_obs)

	rospy.loginfo('Going to Intial Pose')
	jointTarg = planner.init_pose()
	planTraj =  arm.plan_jointTargetInput(jointTarg,0)
	
	if(planTraj!=None):
		arm.group[0].execute(planTraj)
		time.sleep(3)
	else:
		rospy.loginfo('Could not go to Intial Pose')
		time.sleep(1)
		rospy.logerr('Are you running Moveit?')


	rospy.loginfo('Initialization Done')
	
	nPts = 0
	real_object_position = np.zeros(6)
	obs_error = np.zeros((planner.n_waypoints, planner.nState))

	tf_data = []
	ar_tag_data= []
	err_data = []
	
	

	# Give some initial observation
	while (not(rospy.is_shutdown()) and nPts < planner.n_waypoints):
		# Current pose of the arm
		# tarPose = arm.group[0].get_current_pose().pose
		
		# jointCur = arm.robot.get_current_state()
		# print "Current Joint Angles= ", jointCur

		jointTarg = planner.waypts[nPts]

		# print "Setting Next Joint angle target point", jointTarg

		if jointTarg == None:
			rospy.loginfo('IK calculation step: FAILED')
			continue

		rospy.loginfo('IK calculation step:DONE')       
		
				
		# planning with joint target from IK 
		planTraj =  arm.plan_jointTargetInput(jointTarg,0)
		rospy.loginfo('Planning step with target joint angles:DONE')

		if(planTraj!=None):
			# rospy.loginfo('"Going to New Point"')
			# raw_input('Executing Arm Trajectory. Press Enter')
		  	arm.group[0].execute(planTraj)
		  	time.sleep(3)
		else:
			rospy.loginfo('Could not find a Plan')
			time.sleep(1)
			continue

		rospy.sleep(2)
		# raw_input('If Trajectory execution finished, Press Enter')

		 
		z_obs = tags.getObservation()
		print "Going to point =", nPts, "\n\n\n"
		rospy.loginfo('Observation Received')
		real_object_pos = planner.tfBuffer.lookup_transform('linear_actuator_link', 'object_frame', rospy.Time(), rospy.Duration(1.0))

		if tags.gotData == False:
			continue

		quat = (real_object_pos.transform.rotation.x, real_object_pos.transform.rotation.y, real_object_pos.transform.rotation.z, real_object_pos.transform.rotation.w)
		euler = tf.transformations.euler_from_quaternion(quat)

		real_object_position[0] = real_object_pos.transform.translation.x
		real_object_position[1] = real_object_pos.transform.translation.y
		real_object_position[2] = real_object_pos.transform.translation.z
		real_object_position[3] = euler[0]
		real_object_position[4] = euler[1]
		real_object_position[5] = euler[2]
		# real_object_position[3] = real_object_pos.transform.rotation.x
		# real_object_position[4] = real_object_pos.transform.rotation.y
		# real_object_position[5] = real_object_pos.transform.rotation.z
		# real_object_position[6] = real_object_pos.transform.rotation.w



		obs_error[nPts,:] = real_object_position - z_obs

		print "Observation from TF =", real_object_position
		print "ar_tag observation =", z_obs
		print "Error =", real_object_position - z_obs

		tf_data.append(real_object_position*1.)
		ar_tag_data.append(z_obs*1.)
		err_data.append(real_object_position - z_obs)

		nPts += 1

	print "Trajectory Execution Finished"
	print "observation_error = \n", obs_error
	print "Maximum Errors =", [round(max(np.amax(obs_error[:,i]), np.amin(obs_error[:,i]), key=abs),3) for i in range(np.shape(obs_error)[1])]
	max_err = [round(max(np.amax(obs_error[:,i]), np.amin(obs_error[:,i]), key=abs),3) for i in range(np.shape(obs_error)[1])]
	# #plotting(planner.nState, planner.traj, planner.traj_true)	
	# print "Maximum observation error = ", np.amax(obs_error, axis=1)
	BASE_PATH = os.path.dirname(os.path.abspath(__file__))
	file_name = 'data/gemini_obs_err_mat_calculation_run1.npz'
	np.savez(os.path.join(BASE_PATH, file_name), tf_data=tf_data, ar_tag_data=ar_tag_data, err_data=err_data, max_err=max_err)
	print "Hit Ctrl+C Now"

if __name__ == '__main__':
	## First initialize moveit_commander and rospy.
	moveit_commander.roscpp_initialize(sys.argv)
	rospy.init_node('gen_obs_fn', anonymous=True)
	main()
	rospy.spin()


